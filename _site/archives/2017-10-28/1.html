<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>浅析通过'监控'来辅助进行漏洞挖掘 · Chen's Blog</title> <meta name="description" content="前言"> <link rel="icon" href="http://localhost:4000/assets/favicon.png"> <link rel="apple-touch-icon" href="http://localhost:4000/assets/touch-icon.png"> <link rel="stylesheet" href="http://localhost:4000/assets/core.css"> <link rel="canonical" href="http://localhost:4000/archives/2017-10-28/1"> <link rel="alternate" type="application/atom+xml" title="Chen's Blog" href="http://localhost:4000/feed.xml" /> <link href="/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" media="all" /> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?e4a42a371cc5994ee02b940034c29658"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> </head> <body> <aside class="logo"> <a href="http://localhost:4000/"> <img src="/assets/avatar.jpg" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <article> <h1 class="title">Author[#]Vulkey_Chen</h1> <div class="divider"></div> <center><a href="/about">关于我</a> | <a href="/links">友情链接</a> | <a href="/AssistTool">Windows进程对比杀软信息&辅助提权补丁对比</a></center> <div class="divider"></div> </article> <div id="content"> <article> <div class="center"> <h1 class="title">浅析通过'监控'来辅助进行漏洞挖掘</h1> <time class="code">October 28, 2017</time> </div> <div class="divider"></div> <h1 id="前言">前言</h1> <p>这篇文章总结了一些笔者个人在漏洞挖掘这一块的”姿势”，看了下好像也没相关类似TIPs或者文章出现，就写下此文。 <!-- more --></p> <p>“监控”一词，相信大家很常见，例如：xxx酒店厕所被安装监控、xxx明星被狗仔24小时监控，也有奶权师傅写过的<strong>《Python系列之——利用Python实现微博监控》</strong>和笔者写过的<strong>《从编写知乎粉丝监控到漏洞挖掘再到盗号》</strong>。</p> <p>但这跟”漏洞挖掘”联系起来的话似乎就让人摸不着头脑，其实不然，通过”监控”可以帮我们做很多事。</p> <h1 id="监控狂人的修炼之路">监控狂人的修炼之路</h1> <p>以大家最常见的一个东西起-&gt;扫描器，其可以辅助渗透测试工程师更好更简单的进行漏洞的信息发现，但是发现漏洞后要测试漏洞的时候哪些验证步骤是不是就很头疼呢？通过”监控”去完成是不是更好~</p> <p>在我们做盲测漏洞的时候可能会考虑到一些问题，最主要的问题肯定就是什么时候平台能收到结果呢？</p> <p>这时候就可以对接一些平台的<code class="language-plaintext highlighter-rouge">API</code>进行<strong>关键字监控</strong>了。</p> <p>使用<code class="language-plaintext highlighter-rouge">ceye</code>的<code class="language-plaintext highlighter-rouge">API</code>接口对<code class="language-plaintext highlighter-rouge">SSRF</code>漏洞进行<strong>长期监控</strong>：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>API: /api/record?token={token}&amp;type={dns|request}&amp;filter={filter}
token: your ceye token.
type: type of query, 'dns' or 'request'.
filter: match {filter}.{your domain}.ceye.io rule, but limit 20.
</code></pre></div></div> <p>用<code class="language-plaintext highlighter-rouge">Python</code>写一个监控然后再写个发信，这样在有些环境下迟迟到来的漏洞信息就会立即被在床上玩手机的你知道了。</p> <p><strong>其实如上的思路还可以利用很多结合dnslog的原理去监控，这里借助了ceye这个平台的API，还可以参考Bugscan的 dnslog平台 自己去搭建一个然后噼里啪啦，这里其实Burpsuite的Scanner模块就借助了这样的思路去更快捷的扫描发现SSRF漏洞，但是却没办法做到长时间的”蛰伏期”（也就是在一些情况下，结果是需要一个等待才能到达），那其实大家可以继续开拓自己的思维去想些更有价值的东西。</strong></p> <p>如上说的一些”姿势”可能是废话了，很多人都自己多多少少都有想过也实现了，但是别急，前菜清淡，但主菜呢，邀君共品~</p> <p>很多的时候，朋友就会问我xxCMS后台怎么<code class="language-plaintext highlighter-rouge">GetWebshell</code>，为什么那些牛人分分钟都可以<code class="language-plaintext highlighter-rouge">Getwebshell</code>了？除了看代码我怎么快速的获取<code class="language-plaintext highlighter-rouge">GetWebshell</code>的”姿势”呢？</p> <p>一般后台<code class="language-plaintext highlighter-rouge">GetWebshell</code>的”姿势”有这几种：<code class="language-plaintext highlighter-rouge">后台代码/命令执行</code>、<code class="language-plaintext highlighter-rouge">代码闭合</code>、<code class="language-plaintext highlighter-rouge">操作缓存</code>、<code class="language-plaintext highlighter-rouge">文件上传</code>等等…</p> <p>那其实很多的都会本文件打交道，不如先造个文件监控出来：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2017-10-28/0x00.png" alt="img" /></p> <p>造完监控，不如来写个后台<code class="language-plaintext highlighter-rouge">GET/POST</code>请求Fuzz，在做这个Fuzz的时候处理的时候遇到很多坑，脚本写的不是很好就不拿出来丢人现眼了~</p> <p>这里我做的Fuzz是结合<code class="language-plaintext highlighter-rouge">Burpsuite</code>的<code class="language-plaintext highlighter-rouge">日志</code>，进行筛选然后Fuzz：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2017-10-28/0x01.png" alt="img" /></p> <p>这里筛选的脚本是根据 <a href="https://github.com/tony1016/BurpLogFilter">https://github.com/tony1016/BurpLogFilter</a> 去造了一个2.7版本的~</p> <p>其实这个脚本大概的功能实现是这样的：</p> <p>设置<strong>GET/POST</strong>传输参数对应值为随机字符串(这里使用了python的uuid)，会生成一个Fuzz<code class="language-plaintext highlighter-rouge">历史Log</code>文件，以便跟文件监控对比。</p> <p>历史Log对比文件监控：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2017-10-28/0x02.png" alt="img" /></p> <p>这里Fuzz之后发现有两个文件被修改了，而这两个文件因为有CMS特征的存在就不一一例举了。为什么会被修改呢？因为这里传递的值被写入了文件中，找到对应功能点发现有CSRF，一结合就造成了<code class="language-plaintext highlighter-rouge">CSRF+后台GetWebshell</code>~</p> <p>通过如上的姿势测试了不少的CMS，又在CNVD和补天提交相对应也获得了不少的Bounty。</p> <p>在利用这种姿势的情况下偶然发现一个CMS前台访问的时候会生成一个缓存日志文件，而缓存日志文件的内容会记录用户的IP：</p> <div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span> <span class="nx">GET</span> <span class="o">/</span><span class="nx">center</span><span class="o">/</span><span class="nx">useredit</span><span class="o">/</span>
<span class="k">die</span><span class="p">();</span>
<span class="cp">?&gt;</span>
</code></pre></div></div> <p>那其getip()函数的核心代码：</p> <div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">......</span>
<span class="k">if</span><span class="p">(</span><span class="nv">$HTTP_SERVER_VARS</span><span class="p">[</span><span class="s2">"HTTP_X_FORWARDED_FOR"</span><span class="p">]){</span>
    <span class="nv">$ip</span> <span class="o">=</span> <span class="nv">$HTTP_SERVER_VARS</span><span class="p">[</span><span class="s2">"HTTP_X_FORWARDED_FOR"</span><span class="p">];</span>
<span class="p">}</span><span class="k">elseif</span><span class="p">(</span><span class="nv">$HTTP_SERVER_VARS</span><span class="p">[</span><span class="s2">"HTTP_CLIENT_IP"</span><span class="p">]){</span>
    <span class="nv">$ip</span> <span class="o">=</span> <span class="nv">$HTTP_SERVER_VARS</span><span class="p">[</span><span class="s2">"HTTP_CLIENT_IP"</span><span class="p">];</span>
<span class="p">}</span><span class="k">elseif</span> <span class="p">(</span><span class="nv">$HTTP_SERVER_VARS</span><span class="p">[</span><span class="s2">"REMOTE_ADDR"</span><span class="p">]){</span>
    <span class="nv">$ip</span> <span class="o">=</span> <span class="nv">$HTTP_SERVER_VARS</span><span class="p">[</span><span class="s2">"REMOTE_ADDR"</span><span class="p">];</span>
<span class="p">}</span><span class="k">elseif</span> <span class="p">(</span><span class="nb">getenv</span><span class="p">(</span><span class="s2">"HTTP_X_FORWARDED_FOR"</span><span class="p">)){</span>
    <span class="nv">$ip</span> <span class="o">=</span> <span class="nb">getenv</span><span class="p">(</span><span class="s2">"HTTP_X_FORWARDED_FOR"</span><span class="p">);</span>
<span class="p">}</span><span class="k">elseif</span> <span class="p">(</span><span class="nb">getenv</span><span class="p">(</span><span class="s2">"HTTP_CLIENT_IP"</span><span class="p">)){</span>
    <span class="nv">$ip</span> <span class="o">=</span> <span class="nb">getenv</span><span class="p">(</span><span class="s2">"HTTP_CLIENT_IP"</span><span class="p">);</span>
<span class="p">}</span><span class="k">elseif</span> <span class="p">(</span><span class="nb">getenv</span><span class="p">(</span><span class="s2">"REMOTE_ADDR"</span><span class="p">)){</span>
    <span class="nv">$ip</span> <span class="o">=</span> <span class="nb">getenv</span><span class="p">(</span><span class="s2">"REMOTE_ADDR"</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">......</span>
</code></pre></div></div> <p>可以通过<code class="language-plaintext highlighter-rouge">伪造XFF头</code>进行PHP代码的闭合造成前台无限制GetWebshell，但是缓存文件的路径是：/www/center/temp/<strong>md5(text)</strong>.php</p> <p>通过代码了解到其的文件的命名规则是<code class="language-plaintext highlighter-rouge">md5(time())</code>，那其实通过记录前后的一部分时间戳加上Burpsuite的Intruder模块进行md5加密枚举就行了。</p> <p>那其实还可以做一些Fuzz然后实时监控Mysql的SQL执行语句：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2017-10-28/0x03.png" alt="img" /></p> <p>首先来看下Mysql的<code class="language-plaintext highlighter-rouge">记录Log功能</code>开了没有：</p><pre><code class="language-mysql">SHOW VARIABLES LIKE "general_log%";
</code></pre><p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2017-10-28/0x04.png" alt="img" /></p> <p>看见其的功能OFF了~只要设置下ON就行了：</p><pre><code class="language-mysql">SET GLOBAL general_log = 'ON';
</code></pre><p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2017-10-28/0x05.png" alt="img" /></p> <p>使用BareTail进行监控或者自己根据Log的文本规则监控就行了：</p> <p><img src="https://chen-blog-oss.oss-cn-beijing.aliyuncs.com/2017-10-28/0x06.png" alt="img" /></p> <h1 id="结尾">结尾</h1> <p>本文不足之处欢迎指出，也希望大家可以GET到一点点思路，欢迎跟笔者交流。</p> <p>下一篇已经在草稿中了，是关于自动化Fuzz方面的内容，期待吧。</p> </article> <div class="page-navigation code"> <a class="next" href="http://localhost:4000/archives/2017-12-20/1" title="NEXT: 鸡肋点搭配ClickJacking攻击-获取管理员权限">&lt;&lt;</a> <span> &middot; </span> <a class="home" href="http://localhost:4000/" title="Back to Index">Index</a> <span> &middot; </span> <a class="prev" href="http://localhost:4000/archives/2017-03-29/1" title="PREV: 文件寄生——NTFS文件流实际应用">&gt;&gt;</a> </div> </div> <div class="footer"> <span class="block">&lt;/&gt; Copyright &copy; Vulkey_Chen's Blog (GH0ST.CN) 2016-2020</span> </div> <script src="/fancybox/lib/jquery-1.10.2.min.js"></script> <script type="text/javascript" src="/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script> <script> $(document).ready(function() { $("article img").each(function() { var strA = "<a style='text-decoration: none;' id='imgid' href='" + this.src + "'></a>"; $(this).wrapAll(strA); }); }); $("#imgid").fancybox({ openEffect : 'elastic', closeEffect : 'elastic', }); </script> </body> </html>
